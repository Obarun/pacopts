#!/bin/bash
# This script is under license BEER-WARE
# "THE BEER-WARE LICENSE" (Revision 42):
# <eric@obarun.org> wrote this file.  As long as you retain this notice you
# can do whatever you want with this stuff. If we meet some day, and you think
# this stuff is worth it, you can buy me a beer in return.   Eric Vidal

#shopt -s extglob

sourcing(){
	
	local list
	
	for list in /usr/lib/obarun/common_functions /etc/obarun/pacopts.conf; do
		if [[ -f "${list}" ]]; then
			source "${list}"
		else
			echo_error " Missing file : ${list}"
			exit	
		fi
	done
	
	unset list
}
#sourcing

COWER_CONFIG="$HOME/.config/cower/config"
OPTS_COWER="--color"
SP="---" # character to use to know if the commandline on manage_aur_* is a list or not

## 		common functions

usage(){
	cat << EOF
	
${bold}Usage: ${0} [options] [args]${reset}

${bold}options:${reset}
    
    origin : check origin of packages
    applysys : wrap up a sysusers file 
    applytmp : wrap up all tmpfiles
    aur : manage package from AUR repositories
    
${bold}args :${reset}
    
    for origin :
        give the name of the repo to check.
        if an empty value is detected,
        obarun is picked by default.
	
    for applysys :
        name of the file to parse.
        can be a list e.g. "nbd.conf qemu.conf"
    
    for applytmp :
        this option do not accept any args.
        
    for	aur :
        this option do not accept any args.
EOF
	exit 0
}

##			ORIGIN FUNCTIONS

# ${1} name of the repos to use
find_origin(){
	local ori check ver repo_origin parse_ori parse_ori_repo parse_ori_name parse_ori_version
	
	repo_origin="${1}"
	
	for check in ${both[@]};do 
		
		if [[ "$check" != obarun-@(mkiso|install|build) ]]; then
		
			printf "\r${bold}     -> Check %s package${reset}" "$check"
			tput el #return to the last line
		
			while read ori; do
			
				parse_ori=${ori}
				
				#retrieve only the repo
				parse_ori_repo=${parse_ori%%/*}
			
				# retrieve only the name
				parse_ori_name=${parse_ori##*/}
				parse_ori_name=${parse_ori_name%%' '*}
				
				#retrieve only the version
				#if the value not return a version format then the package do not come from $repo_origin
				if [[ "${parse_ori_name}" == "$check" ]]; then ## avoid search regex on packages description
					parse_ori_version=${parse_ori##*[}
					ver=$(grep ":" <<< "${parse_ori_version}")
					
					if [[ -n "${ver}" ]];then
						parse_ori_version=${parse_ori_version##*' '}
						parse_ori_version=${parse_ori_version%%]*}
					else
						unset parse_ori_version
					fi
					unset ver
				fi
				
				check_var(){
					printf "\n"
					echo ori :: ${ori}
					echo parse_ori :: ${parse_ori}
					echo parse_ori_repo :: ${parse_ori_repo%%/}
					echo parse_ori_name :: ${parse_ori_name}
					echo ver :: ${ver}
					echo parse_ori_version :: ${parse_ori_version}
				}
				#check_var
				
				# version is not empty, the package installed do not come from $repo_origin
				if [[ -n $parse_ori_version ]]; then
					false+=("$check")
				fi
				
				unset parse_ori parse_ori_repo parse_ori_name parse_ori_version
			
			done < <(pacman -Ss "$check" | grep "${repo_origin}")
		fi
	done
	 
	printf "\n${bold}==>> Finished ${reset}\n"

	unset ori check ver repo_origin parse_ori parse_ori_repo parse_ori_name parse_ori_version
}

# ${1} name of the repos to use
# if empty, obarun is set by default
check_package(){
	
	local named item repo
	local -a both false repo_db
	
	# pick obarun by default
	repo="${1:-obarun}"
	
	mapfile -t repo_db < <(pacman -Slq "${repo}")
	
	# FILTER : Compare list of $installed package and $repo database,
	# if exist on twice put it on $both array
		
	while read named;do 
		for item in ${repo_db[@]}; do #$(pacman -Slq obarun)
			if  [[ "$named" == "$item" ]]; then 
				both+=("$item")
			fi
		done
	done < <(pacman -Qsq)
	
	echo_display " Verifying ${repo} packages repository"
	
	#check origin of package
	find_origin "${repo}"
	
	if ! [[ -z "${false[@]}" ]]; then 
		printf "${byellow}==>> These/those package(s) do not come from ${repo} repository :${reset}\n" 
		for no in "${false[@]}"; do
			echo_bold "	-> $no"
		done
		echo_display " Do you want to replace this/those package(s) [y|n]"
		reply_answer
		if (( ! $? )); then
			for i in "${false[@]}"; do
				pacman -S "${repo}"/$i
			done
		fi
	fi
	
	unset named item repo both false repo_db
}



##				SYSUSERS FUNCTION

# ${1} path to the file
# ${2} file to parse, can be a list e.g. "nbd.conf quemu.conf"
parse_file(){
	
	local tidy_loop path_file check parse_check
	local -a named
	
	path_file="${1}"
	named=( "${2}" )
	
	for tidy_loop in ${path_file}/${named[@]}; do
		
		tidy_loop=${tidy_loop##*/}

		while read check; do
	
			while read -d " " parse_check;do 
				case $parse_check in 
					u|g|m|r)
						parse_line "${parse_check}" "${check} "
						;;
					*) continue ;;
				esac
			done <<< "${check}"
	
		done < "${path_file}/${tidy_loop}"
	
	done 
	
	unset named tidy_loop path_file check parse_check
}

# {1} sysusers options : mean u,g,m or r
# {2} complete line to parse
parse_line(){
	 
	opts="${1}"
	line="${2}"
	
	case "${opts}" in
		u) 	line_u		
			;;
		g) 	line_g
			;;
		m) 	line_m
			;;
		r)	line_r
			;;
	esac	
	
	
}

# {1} line to parse
check_args(){
	
	local what element
	what="${1}"

	while read -d " " element; do
		case "${element}" in
			u|g|r) continue 
					;;
			m) 	named_g=$(awk -F " " '{print $2 }' <<< ${what})
				group_g=$(awk -F " " '{print $3 }' <<< ${what})
				;;	
			\"*) comment_=$(awk -F "\"*\"" '{ print $2 }' <<< ${what})
				;;
			*[0-9])
				uidgid="${element}"		
				;;
			/*)
				directory_="${element}"
				;;
			-) 	continue
				;;
			*\") continue
				;;
			*[a-z]|*[A-z])
				echo ${what} | awk -F "${element}" '{ print $1 }' | grep \" &>/dev/null
				if [[ $? -eq 0 ]]; then
					continue
				else
					named_="${element}"
				fi
				;;
		esac
	done <<< "${what}"
	
	unset what element
}

line_u(){
	local named_ directory_ optdirectory_ optdirectory_v uidgid optgid optgid_v optuid optuid_v comment_ optcomment optcomment_v

	check_args "${line}"
	
	if [[ -z "${directory_}" ]]; then
		optdirectory="-d"
		optdirectory_v="/"
	else
		optdirectory="-d"
		optdirectory_v="${directory_}"
	fi
	if [[ -z "${uidgid}" ]]; then
		optgid=""
		optgid_v=""
		optuid=""
		optuid_v=""
	else
		optgid="-g"
		optgid_v="${uidgid}"
		optuid="-u" 
		optuid_v="${uidgid}"
	fi
	if [[ -z "${comment_}" ]]; then
		optcomment=""
		optcomment_v=""
	else
		optcomment="-c" 
		optcomment_v="${comment_}"
	fi
	
	getent group ${named_} &>/dev/null
	if [[ $? -eq 0 ]]; then
		echo_info " group ${named_} already exist, nothing to do"
	else
		echo_display " Creating group ${named_} with the option(s):"
		echo_display " ${optgid} ${optgid_v}" 
		groupadd -r "${optgid}" "${optgid_v}" "${named_}" || die " Impossible to create group ${named_}"
	fi
	
	getent passwd ${named_} &>/dev/null
	if [[ $? -eq 0 ]]; then
		echo_info " user ${named_} already exist, nothing to do"
	else
		echo_display " Creating user ${named_} with the option(s):"
		echo_display " ${optuid} ${optuid_v} ${optgid} ${optgid_v} ${optdirectory} ${optdirectory_v} ${optcomment} ${optcomment_v} -s /sbin/nologin"
		useradd -r "${optuid}" "${optuid_v}" "${optgid}" "${optgid_v}" "${optdirectory}" "${optdirectory_v}" "${optcomment}" "${optcomment_v}" -s /sbin/nologin "${named_}"	|| die " Impossible to create user ${named_}"
	fi
	
	unset named_ directory_ optdirectory_ optdirectory_v uidgid optgid optgid_v optuid optuid_v comment_ optcomment optcomment_v
}
line_g(){
	local uidgid optgid optgid_v optuid optuid_v named_
	
	check_args "${line}"
	
	if [[ -z "${uidgid}" ]]; then
		optgid=""
		optgid_v=""
		optuid=""
		optuid_v=""
	else
		optgid="-g"
		optgid_v="${uidgid}"
		optuid="-u" 
		optuid_v="${uidgid}"
	fi
	
	getent group ${named_} &>/dev/null
	if [[ $? -eq 0 ]]; then
		echo_info " group ${named_} already exist, nothing to do"
	else	
		echo_display " Creating group ${named_} with the option(s):"
		echo_display " ${optgid} ${optgid_v}"
		groupadd -r "${optgid}" "${optgid_v}" "${named_}" || die " Impossible to create group ${named_}"
	fi
	
	unset uidgid optgid optgid_v optuid optuid_v named_
}

line_m(){
	local named_g group_g uidgid optgid optgid_v optuid optuid_v directory_ optdirectory_ optdirectory_v comment_ optcomment optcomment_v
	
	check_args "${line}"
	
	if [[ -z "${directory_}" ]]; then
		optdirectory=""
		optdirectory_v=""
	else
		optdirectory="-d"
		optdirectory_v="${directory_}"
	fi
	
	if [[ -z "${uidgid}" ]]; then
		optgid=""
		optgid_v=""
		optuid=""
		optuid_v=""
	else
		optgid="-g"
		optgid_v="${uidgid}"
		optuid="-u" 
		optuid_v="${uidgid}"
	fi
	
	if [[ -z "${comment_}" ]]; then
		optcomment=""
		optcomment_v=""
	else
		optcomment="-c" 
		optcomment_v="${comment_}"
	fi
	
	getent group ${group_g} &>/dev/null
	if [[ $? -ne 0 ]]; then
		echo_info " group ${group_g} does not exist, create it"
		groupadd -r "${optgid}" "${optgid_v}" "${group_g}" || die " Impossible to create group ${group_g}"
	fi
	
	getent passwd ${named_g} &>/dev/null
	if [[ $? -ne 0 ]]; then
		echo_info " user ${named_g} does not exist, create it"
		echo useradd -r "${optuid}" "${optuid_v}" "${optgid}" "${optgid_v}" "${optdirectory}" "${optdirectory_v}" "${optcomment}" "${optcomment_v}" "${named_g}" || die " Impossible to create user ${named_g}"
	fi
	
	echo_display " Add user ${named_g} to group ${group_g}"
	gpasswd -a "${named_g}" "${group_g}" || die " Impossible to add ${named_g} to group ${group_g}"
	
	unset named_g group_g uidgid optgid optgid_v optuid optuid_v directory_ optdirectory_ optdirectory_v comment_ optcomment optcomment_v
}

line_r(){
	echo_info " Pacopts cannot parse the file ${path_file}/${named} for r line,"
	echo_info " you need to do it manually"
	break
}

##				TMPFILE FUNCTION

tmpfiles(){
	/usr/lib/obarun/tmpfiles.sh --create
}


## 				AUR FUNCTION

# function to find which installer to use for a given package
# return 10 for pacman, 11 for AUR helper
# ${1} name of package
choose_installer(){
	
	local b named
		
	named="${1}"
		
	for b in $(pacman -Ssq ${named[@]}); do
		if [[ $named =~ $b ]] ; then
			return 10			
		fi
	done
	unset b
	
	for b in $(cower -sq ${named[@]}); do
		if [[ $named =~ $b ]] ; then
			return 11			
		fi
	done
	unset b
	
	# be sure the named are not a group
	# if it's the case return value for pacman
	
	for b in $(pacman -Sgq ${named[@]}); do
		if [[ $named =~ $b ]] ; then
			return 10			
		fi
	done
		
	unset named b
}

# ${1} array to parse
manage_aur_is_array(){
	
	local -a _array
	_array=( ${1} )

	if check_elements "${SP}" ${_array[@]}; then
		parse_ans=${ans[@]}
		named=${ans[@]}
		named=${named%%---*}
		ans_args=${parse_ans##*---}
		return 0
	else
		parse_ans=${ans[@]}
		named=${parse_ans%%' '*}
		ans_args=${parse_ans##*' '}
		if [[ "${named}" == "${ans_args}" ]]; then
			unset ans_args
		fi
		return 1
	fi
}

# ${1} command to pass to cower
# ${2} cower arguments to pass
cower_cmd(){
	
	local opts
	
	cmd="${1}"
	opts=( "${2}" )
	
	cower "${cmd}" ${opts[@]} || unset opts && return 1
	
	unset opts
	
	return 0
}

# ${1} name of the package
install_scheme(){
	
	local named scheme_functions
	named="${1}"
	
	for scheme_functions in scheme_{get_pkgbuild,dependencies,build,install}; do
		"${scheme_functions}" "${named}"
		if (( $? )); then
			return 1
		fi
	done
	
	unset named scheme_functions
	
	return 0
}

# ${1} name of the package
scheme_get_pkgbuild(){
	
	local named 
		
	named="${1}"
	
	printf "\n"
	printf "%s\n" "${info} :: Get ${bold}${named}${reset} PKGBUILD"
	printf "\n"
	
	search_in_dir "${work_dir}" "${named}" "PKGBUILD"
	if (( ! $? )); then
		printf "%s" "Manage ${bold}${info}${reset} :: ${named} exist, overwrite it?[y|n] > "
		reply_answer
		if (( ! $? )); then
			cower_cmd "-df" "${named} ${ans_args[@]} ${OPTS_COWER[@]}" 
		else
			return 1
		fi
	else	
		cower_cmd "-d" "${named} ${ans_args[@]} ${OPTS_COWER[@]}" 
	fi
	
	unset named
	
	return 0
}

# ${1} name of the package
scheme_dependencies(){
	
	local named tidy_loop
	local -a dps dps_parsed
	
	named="${1}"
	dps=$(cower -i $named --format=%D) # Depends
	dps+=($(cower -i $named --format=%M)) # Makedepends
	
	printf "\n"
	printf "%s\n" "${info} :: Check dependencies for ${bold}${named}${reset}"
	printf "\n"
	
	# parse each element of the array to remove any <>= characters
	for tidy_loop in ${dps[@]}; do
		#echo tidy_loop :: $tidy_loop
		tidy_loop=${tidy_loop%%@(>|<|=)*}
		#echo tidy_loop parsed :: $tidy_loop
		dps_parsed+=("$tidy_loop")
	done
	unset tidy_loop
	
	# loop through dependencies recursively
	for tidy_loop in ${dps_parsed[@]}; do
		
		choose_installer "${tidy_loop}"
		
		rc=$?
		
		if [[ "$rc" == 11 ]];then
			scheme_dependencies "${tidy_loop}"
			scheme_install "${tidy_loop}"
		fi
	done
	
	unset named dps dps_parsed tidy_loop
	
	return 0
}

# ${1} name of the package
# ${2} working directory
scheme_build(){
	
	local named 
	named="${1}"
	
	printf "\n"
	printf "%s\n" "${info} :: Build ${bold}${named}${reset}"
	printf "\n"
	
	pushd "${named}" &>/dev/null
	
	search_in_dir "${work_dir}" "${named}" "${named}"*.pkg.tar.xz
	if (( ! "$?" )); then
		printf "%s" "Manage ${bold}${info}${reset} :: ${named} compiled package exist, overwrite it?[y|n] > "
		reply_answer
		if (( ! "$?" )); then
				makepkg -f ${OPTS_MAKEPKG[@]} || return 1
		else
			return 1
		fi
	else
		makepkg ${OPTS_MAKEPKG[@]} || return 1
	fi
	
	popd &>/dev/null
	
	unset named
	
	return 0
}

scheme_install(){
	
	local named
	
	named="${1}"
	
	printf "\n"
	printf "%s\n" "${info} :: Install ${bold}${named}${reset}"
	printf "\n"
	
	pushd "${named}" &>/dev/null
	su -c "pacman ${OPTS_PACMAN[@]} ${named}-*.pkg.tar.xz" || return 1
	popd &>/dev/null
	
	unset named
	
	return 0
}

manage_aur_download(){
	
	local info named rc tidy_loop
	local -a parse_ans ans_args ans
	
	info="${1}"
		
	while true; do
		
		unset named
		
		printf "\n"
		read -p "Manage ${bold}${info}${reset} :: enter a name > " ans
		printf "\n"
		
		named="${ans}"
		
		case "${ans}" in
			@(info|msearch|search|update|install|build)) 
				rc=1
				break
				;;
			help)
				cower_cmd "-h"
				;;
			quit) 
				exit
				;;
			*) 	manage_aur_is_array "${ans[@]}"
				
				if (( ! "$?" )); then
					for tidy_loop in ${named[@]}; do
						printf "%s\n" "${info} :: ${bold}${tidy_loop}${reset}"
						printf "\n"
						cower_cmd "-d" "${tidy_loop} ${ans_args[@]} ${OPTS_COWER[@]}"
						printf "\n"
					done
				else
					cower_cmd "-d" "${named[@]} ${ans_args[@]} ${OPTS_COWER[@]}"
				fi
				unset rc
				;;
		esac
	done
	if (( $rc )); then
		manage_aur 0 "${ans}"
	fi
	
	unset info named rc parse_ans ans_args ans tidy_loop
}

manage_aur_info(){
	
	local info named rc tidy_loop
	local -a parse_ans ans_args ans
	
	info="${1}"
	
	while true; do
		
		unset named
		
		printf "\n"
		read -p "Manage ${bold}${info}${reset} :: enter a name > " ans
		printf "\n"
			
		named="${ans}"
			
		case "${ans}" in
			@(download|msearch|search|update|install|build)) 
				rc=1
				break
				;;
			help)
				cower_cmd "-h"
				;;
			quit) 
				exit
				;;
			*) 	manage_aur_is_array "${ans[@]}"
				
				if (( ! "$?" )); then
					for tidy_loop in ${named[@]}; do
						printf "%s\n" "${info} :: ${bold}${tidy_loop}${reset}"
						cower_cmd "-i" "${tidy_loop} ${ans_args[@]} ${OPTS_COWER[@]}"
						printf "\n"
					done
				else
					cower_cmd "-i" "${named[@]} ${ans_args[@]} ${OPTS_COWER[@]}"
				fi
				unset rc
				;;
		esac
	done
	if (( $rc )); then
		manage_aur 0 "${ans}"
	fi
	
	unset info named rc parse_ans ans_args ans tidy_loop
}

manage_aur_msearch(){
	
	local info named rc tidy_loop
	local -a parse_ans ans_args ans
	
	info="${1}"
	
	while true; do
		
		unset named
		
		printf "\n"
		read -p "Manage ${bold}${info}${reset} :: enter a name > " ans
		printf "\n"
		
		named="${ans}"
		
		case "${ans}" in
			@(download|info|search|update|install|build)) 
				rc=1
				break
				;;
			help)
				cower_cmd "-h"
				;;
			quit) 
				exit
				;;
			*) 	manage_aur_is_array "${ans[@]}"
				
				if (( ! "$?" )); then
					for tidy_loop in ${named[@]}; do
						printf "%s\n" "${info} :: ${bold}${tidy_loop}${reset}"
						printf "\n"
						cower_cmd "-m" "${tidy_loop} ${ans_args[@]} ${OPTS_COWER[@]}"
						printf "\n"
					done
				else
					cower_cmd "-m" "${named[@]} ${ans_args[@]} ${OPTS_COWER[@]}"
				fi
				unset rc
				;;
		esac
	done
	if (( $rc )); then
		manage_aur 0 "${ans}"
	fi
	
	unset info named rc parse_ans ans_args ans tidy_loop
}

manage_aur_search(){
	
	local info named rc tidy_loop
	local -a parse_ans ans_args ans
	
	info="${1}"
	
	while true; do
		
		unset named
		
		printf "\n"
		read -p "Manage ${bold}${info}${reset} :: enter a name > " ans
		printf "\n"
		
		named="${ans}"
		
		case "${ans}" in
			@(download|info|msearch|update|install|build)) 
				rc=1
				break
				;;
			help)
				cower_cmd "-h"
				;;
			quit) 
				exit
				;;
			*) 	manage_aur_is_array "${ans[@]}"
				
				if (( ! "$?" )); then
					for tidy_loop in ${named[@]}; do
						printf "%s\n" "${info} :: ${bold}${tidy_loop}${reset}"
						printf "\n"
						cower_cmd "-s" "${tidy_loop} ${ans_args[@]} ${OPTS_COWER[@]}"
						printf "\n"
					done
				else
					cower_cmd "-s" "${named[@]} ${ans_args[@]} ${OPTS_COWER[@]}"
				fi
				unset rc
				;;
		esac
	done
	if (( $rc )); then
		manage_aur 0 "${ans}"
	fi
	
	unset info named rc parse_ans ans_args ans tidy_loop
}

manage_aur_update(){
	
	local info named rc tidy_loop
	local -a parse_ans ans_args ans
	
	info="${1}"
	
	while true; do
		
		unset named

		printf "\n"
		read -p "Manage ${bold}${info}${reset} :: enter a name, leave blank for all packages > " ans
		printf "\n"
		
		named="${ans}"
		
		case "${ans}" in
			@(download|info|msearch|search|install|build)) 
				rc=1
				break
				;;
			help)
				cower_cmd "-h"
				;;
			quit) 
				exit
				;;
			*) 	if [[ -z "${ans[@]}" ]]; then ## no name, so check all packages
					cower_cmd "-u" "${OPTS_COWER[@]}"
					continue
				fi
				manage_aur_is_array "${ans[@]}"
				
				if (( ! "$?" )); then
					for tidy_loop in ${named[@]}; do
						printf "%s\n" "${info} :: ${bold}${tidy_loop}${reset}"
						cower_cmd "-u" "${tidy_loop} ${ans_args[@]} ${OPTS_COWER[@]}"
						printf "\n"
					done
				else
					cower_cmd "-u" "${named[@]} ${ans_args[@]} ${OPTS_COWER[@]}"
				fi
				unset rc
				;;
		esac
	done
	if (( $rc )); then
		manage_aur 0 "${ans}"
	fi
	
	unset info named rc parse_ans ans_args ans tidy_loop
}

manage_aur_install(){
	
	local info named rc work_dir
	local -a parse_ans ans_args ans
	
	source "${COWER_CONFIG}"
	
	info="${1}"
	work_dir="${TargetDir:-/tmp}"
	
	check_dir "${work_dir}"
	if (( "$?" )); then
		mkdir -p "${work_dir}"
	fi
	
	while true; do
		
		pushd "${work_dir}" &>/dev/null
		
		unset named
		
		printf "\n"
		read -p "Manage ${bold}${info}${reset} :: enter a name > " ans
		printf "\n"
			
		named="${ans}"
		
		case "${ans}" in
			@(download|info|msearch|search|update|build)) 
				rc=1
				break
				;;
			help)
				manage_aur_install_help
				;;
			quit) 
				exit
				;;
			*) manage_aur_is_array "${ans[@]}"
				
				if (( ! "$?" )); then
					for tidy_loop in ${named[@]}; do
						printf "%s\n" "${info} :: ${bold}${tidy_loop}${reset}"
						printf "\n"
						install_scheme "${tidy_loop}"
						printf "\n"
					done
				else
					install_scheme "${named}"
				fi
				;;
		esac
	done
	if (( $rc )); then
		manage_aur 0 "${ans}"
	fi
	
	unset info named rc parse_ans ans_args ans tidy_loop work_dir
}

manage_aur_build(){
	
	local info named rc work_dir scheme
	local -a parse_ans ans_args ans
	
	source "${COWER_CONFIG}"
	
	info="${1}"
	work_dir="${TargetDir:-/tmp}"
	
	check_dir "${work_dir}"
	if (( "$?" )); then
		mkdir -p "${work_dir}" || die " Impossible to create the working directory"
	fi
	
	while true; do
		
		pushd "${work_dir}" &>/dev/null
		
		unset named
		
		printf "\n"
		read -p "Manage ${bold}${info}${reset} :: enter a name > " ans
		printf "\n"
			
		named="${ans}"
		
		case "${ans}" in
			@(download|info|msearch|search|update|install)) 
				rc=1
				break
				;;
			help)
				echo manage_aur_info_help :: display help for info command
				;;
			quit) 
				exit
				;;
			*) manage_aur_is_array "${ans[@]}"
				
				
				if (( ! "$?" )); then
					for tidy_loop in ${named[@]}; do
						printf "%s\n" "${info} :: ${bold}${tidy_loop}${reset}"
						printf "\n"
						for scheme in scheme_{get_pkgbuild,build};do 
							"${scheme}" "${tidy_loop}"
							if (( $? )); then
								break
							fi
						done
						printf "\n"
					done
				else
					for scheme in scheme_{get_pkgbuild,build};do 
						"${scheme}" "${named}"
						if (( $? )); then
							break
						fi
					done
				fi
				;;
		esac
	done
	
	if (( $rc )); then
		manage_aur 0 "${ans}"
	fi
	
	unset info named rc parse_ans ans_args ans tidy_loop work_dir scheme
}

manage_aur_help(){
	printf "\n"
	printf "%-15s\n" "The following command are available"
	printf "\n"
	printf "%-15s %-15s\n" "     download" "download a pkgbuild for a given package" >&1
	printf "%-15s %-15s\n" "     info" "get info for a given package" >&1
	printf "%-15s %-15s\n" "     msearch" "search for packages maintained by a given name" >&1
	printf "%-15s %-15s\n" "     search" "search for packages with a given name or regex pattern" >&1
	printf "%-15s %-15s\n" "     update" "check for updates for a given packages" >&1
	printf "%-15s %-15s\n" "     build" "build package(s)" >&1
	printf "%-15s %-15s\n" "     install" "download,build,install package(s) in one pass" >&1
	printf "%-15s %-15s\n" "     quit" "exit from the script" >&1
}

manage_aur_install_help(){
	printf "\n"
	printf "%-15s\n" "help for install command"
	printf "\n"
}

# ${1} first pass or not : 0 for not, 1 for yes
# ${2} cower command or extra command e.g. install

manage_aur(){
	
	(( EUID != 0 )) || die " this part of the must be run without root privilegies" 
	
	if [[ -z "${COWER_CONFIG}" ]]; then
		die " a configuration file for cower need to be present at ${COWER_CONFIG}"
	fi
		
	local cower_cmd _pass
	_pass="${1}"
	manage_cmd="${2}"
	
	if (( "${_pass}" )); then
		printf "\n"
		
		read -p "Manage :: please enter your command > " ans
		manage_cmd="${ans}"
	fi
	
	case $manage_cmd in
			@(d|download))
				manage_aur_download "download"
				;;
			@(i|info))
				manage_aur_info "info"
				;;
			@(m|msearch))
				manage_aur_msearch "msearch"
				;;
			@(s|search))
				manage_aur_search "search"
				;;
			@(u|update))
				manage_aur_update "update"
				;;
			@(in|install))
				manage_aur_install "install"
				;;
			@(b|build))
				manage_aur_build "build"
				;;
			quit)
				exit
				;;
			*)
				manage_aur_help
				manage_aur 1
				;;
	esac
}
